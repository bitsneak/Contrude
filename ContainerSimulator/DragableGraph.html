<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draggable Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .node {
            fill: #000; /* Schwarze Knotenfarbe */
            cursor: pointer;
        }
        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }
        .node text {
            font: 12px sans-serif;
            pointer-events: none;
            fill: #000; /* Schwarze Schriftfarbe */
        }
    </style>
</head>
<body>
<svg width="960" height="600"></svg>

<script>
    // Asynchrones Laden der JSON-Datei
    d3.json('graphSpecific.json').then(function(graphData) {
        // Verbindungen und Knoten vorbereiten
        const nodes = [];
        const links = [];
        const nodeMap = {};  // Um doppelte IDs zu vermeiden

        // Funktion zur Rekursion der Container-Struktur
        function traverse(subs, parentId) {
            subs.forEach(sub => {
                // Wenn der Container noch nicht im nodes-Array ist
                if (!nodeMap[sub.contId]) {
                    nodes.push({ id: sub.contId });
                    nodeMap[sub.contId] = true;
                }
                // Verbindung zwischen parentId und sub.contId
                links.push({ source: parentId, target: sub.contId });
                // Rekursion f체r tiefer verschachtelte Subs
                if (sub.subs && sub.subs.length > 0) {
                    traverse(sub.subs, sub.contId);
                }
            });
        }

        // Der Root-Container (cont4) wird als Startpunkt genutzt
        nodes.push({ id: graphData.contId });
        nodeMap[graphData.contId] = true;

        // Die Verschachtelung der Subs des Root-Containers verarbeiten
        if (graphData.subs) {
            traverse(graphData.subs, graphData.contId);
        }

        // Alle Knoten, die ohne Verbindung sind, als unabh채ngige Knoten hinzuf체gen
        Object.keys(nodeMap).forEach(id => {
            if (!nodes.find(node => node.id === id)) {
                nodes.push({ id });
            }
        });

        // SVG und D3-Setup
        const svg = d3.select('svg');
        const width = +svg.attr('width');
        const height = +svg.attr('height');

        const simulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(links).id(d => d.id).distance(100))
            .force('charge', d3.forceManyBody().strength(-200))
            .force('center', d3.forceCenter(width / 2, height / 2));

        // Links erstellen
        const link = svg.append('g')
            .selectAll('.link')
            .data(links)
            .enter().append('line')
            .attr('class', 'link');

        // Knoten erstellen
        const node = svg.append('g')
            .selectAll('.node')
            .data(nodes)
            .enter().append('g')
            .attr('class', 'node')
            .call(d3.drag()
                .on('start', dragStarted)
                .on('drag', dragged)
                .on('end', dragEnded));

        // Knotenkreis und Text hinzuf체gen
        node.append('circle')
            .attr('r', 20)
            .attr('class', 'node');

        node.append('text')
            .attr('dy', -25)
            .attr('text-anchor', 'middle')
            .text(d => d.id);

        // Simulation tickt und aktualisiert Positionen der Knoten und Verbindungen
        simulation.on('tick', function() {
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            node
                .attr('transform', d => `translate(${d.x},${d.y})`);
        });

        // Drag-Verhalten
        function dragStarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragEnded(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
    }).catch(function(error) {
        console.log(error);
    });
</script>
</body>
</html>
